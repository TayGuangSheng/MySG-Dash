import { NextRequest } from "next/server";type LtaBusResponse = {  BusStopCode: string;  Services: Array<{    ServiceNo: string;    NextBus: Partial<LtaBusTiming>;    NextBus2: Partial<LtaBusTiming>;    NextBus3: Partial<LtaBusTiming>;    Status?: string;  }>;  Message?: string;};type LtaBusTiming = {  EstimatedArrival: string;  Load?: "SEA" | "SDA" | "LSD";};type BusArrival = {  etaMin: number;  load?: "SEA" | "SDA" | "LSD";};type BusServiceEta = {  service: string;  arrivals: BusArrival[];};type BusApiResponse = {  etas: BusServiceEta[];  updatedAt: string;  note?: string;};export const dynamic = "force-dynamic";export async function GET(request: NextRequest) {  const { searchParams } = new URL(request.url);  const stop = searchParams.get("stop");  if (!stop) {    return Response.json({ error: "Missing stop parameter" }, { status: 400 });  }  const accountKey = process.env.LTA_ACCOUNT_KEY;  if (!accountKey) {    return Response.json({ error: "LTA_ACCOUNT_KEY environment variable is not configured." }, { status: 500 });  }  try {    const apiUrl = new URL(      "https://datamall2.mytransport.sg/ltaodataservice/v3/BusArrival",    );    apiUrl.searchParams.set("BusStopCode", stop);    const response = await fetch(apiUrl, {      headers: {        accept: "application/json",        AccountKey: accountKey,      },      next: { revalidate: 15 },    });    if (!response.ok) {      const text = await response.text();      console.error("Bus API error", response.status, text);      return Response.json(        { error: `LTA BusArrival API responded with status ${response.status}` },        { status: 502 },      );    }    const payload = (await response.json()) as LtaBusResponse;    const now = Date.now();    const etas: BusServiceEta[] = payload.Services.map((service) => ({      service: service.ServiceNo,      arrivals: [service.NextBus, service.NextBus2, service.NextBus3]        .map((entry) => normaliseArrival(entry, now))        .filter((arrival): arrival is BusArrival => arrival !== null)        .slice(0, 3),    }))      .filter((service) => service.arrivals.length > 0)      .sort((a, b) => a.service.localeCompare(b.service, undefined, { numeric: true }));    const updatedAt = new Date(now).toISOString();    const result: BusApiResponse = {      etas,      updatedAt,      note: payload.Message,    };    if (etas.length === 0) {      result.note = payload.Message ?? "No upcoming buses reported at this stop.";    }    return Response.json(result, { status: 200 });  } catch (error) {    console.error("Failed to fetch bus arrivals", error);    return Response.json({ error: "Failed to fetch bus arrivals" }, { status: 500 });  }}function normaliseArrival(  entry: Partial<LtaBusTiming> | undefined,  now: number,): BusArrival | null {  if (!entry?.EstimatedArrival) {    return null;  }  const etaTimestamp = Date.parse(entry.EstimatedArrival);  if (!Number.isFinite(etaTimestamp)) {    return null;  }  const diffMinutes = Math.max(0, Math.floor((etaTimestamp - now) / 60000));  return {    etaMin: diffMinutes,    load: entry.Load as BusArrival["load"],  };}